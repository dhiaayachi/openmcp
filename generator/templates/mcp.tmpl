// AUTOGENERATED FILE by openapi-to-mcp-generator. DO NOT EDIT.
// This file was generated from an OpenAPI specification.
// You need to implement the business logic inside the handlers.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"log"
    "net/http"
    _ "bytes"
    "io"
    _ "encoding/json"
    "strings"


	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

const baseURL = "{{.Url}}" // <-- IMPORTANT: Change this to your actual API server URL
// Main function to set up and run the MCP server.
func main() {
	log.Println("Starting generated MCP server...")

	// Create a new MCP server instance.
	// The name and version can be customized.
	mcpServer := server.NewMCPServer(
		"GeneratedAPIServer",
		"1.0.0",
	)

	// Register all the tools discovered from the OpenAPI spec.
	{{range .Endpoints}}
	// Tool: {{.ToolName}}
	// {{.Description}}
	{{.ToolName}}Tool := mcp.NewTool(
		"{{.ToolName}}",
		mcp.WithDescription("{{.Description}}"),
		{{range .Parameters}}
		mcp.With{{.TypeName}}("{{.JSONName}}",
			{{if .Required}}mcp.Required(),{{end}}
			mcp.Description("{{.Description}}"),
		),
		{{end}}
	)
	mcpServer.AddTool({{.ToolName}}Tool, {{.HandlerFuncName}})
	{{end}}

	// Start the server, listening on stdio.
	log.Println("Server configured. Listening for MCP requests...")
	if err := server.ServeStdio(mcpServer); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}

{{range .Endpoints}}
// {{.HandlerFuncName}} is the handler for the '{{.ToolName}}' tool.
// It receives the tool call request and must return a result or an error.
//
// Corresponds to: {{.Method | ToUpperFirst}} {{.Path}}
func {{.HandlerFuncName}}(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	log.Printf("Executing tool '{{.ToolName}}' with arguments: %+v", request.GetArguments())

    client := &http.Client{}
    path := "{{.Path}}"

    // Replace path parameters like {petId} with actual values
    {{range .Parameters}}
    if val, ok := request.GetArguments()["{{.JSONName}}"]; ok {
        path = strings.Replace(path, "{"+"{{.JSONName}}"+"}", fmt.Sprintf("%v", val), -1)
    }
    {{end}}

    // Construct the request body for POST, PUT, PATCH
    var reqBody io.Reader
    {{if or (eq .Method "post") (eq .Method "put") (eq .Method "patch")}}
    bodyMap := make(map[string]interface{})
    {{range .Parameters}}
    if val, ok := request.GetArguments()["{{.JSONName}}"]; ok {
        // Only include body params, not path params
        if !strings.Contains("{{.Path}}", "{"+"{{.JSONName}}"+"}") {
            bodyMap["{{.JSONName}}"] = val
        }
    }
    {{end}}
    if len(bodyMap) > 0 {
        jsonBody, err := json.Marshal(bodyMap)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal request body: %w", err)
        }
        reqBody = bytes.NewBuffer(jsonBody)
    }
    {{end}}

	req, err := http.NewRequest("{{.Method | ToUpperFirst}}", baseURL+path, reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

    // Set headers
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
    // TODO: Add any required authentication headers here

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode >= 400 {
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(respBody))
	}

	return mcp.NewToolResultText(string(respBody)), nil
}
{{end}}