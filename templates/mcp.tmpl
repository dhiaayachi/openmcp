package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"io"
	"net/http"
)

func main() {
    // Create a new MCP server
    s := server.NewMCPServer(
        "{{.MCPServerDesc}}",
        "1.0.0",
        server.WithToolCapabilities(false),
    )

{{range .Tools}}
    // Add tool
    tool := mcp.NewTool("hello_world",
        mcp.WithDescription("{{.Desc}}"),
        mcp.WithString("name",
            mcp.Required(),
            mcp.Description("Name of the person to greet"),
        ),
    )

    // Add tool handler
    s.AddTool(tool, {{.HandlerName}})
{{end}}

    // Start the stdio server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

{{range .Tools}}
func {{.HandlerName}}(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    url := "{{.TargetURL}}"
    	// Send an HTTP GET request to the specified URL.
    	// The http.Get function handles redirects and basic connection management.

    	args := request.GetArguments()

    	buffer := bytes.Buffer{}
    	err := json.NewEncoder(&buffer).Encode(args)
    	if err != nil {
    		// If there's an error during the HTTP request (e.g., network issues, invalid URL),
    		// return the error immediately.
    		err := fmt.Errorf("failed to encode args %s: %w", url, err)
    		return mcp.NewToolResultError(err.Error()), err
    	}

    	httpRequest, err := http.NewRequest("{{.Method}}", url, &buffer)
    	if err != nil {
    		// If there's an error during the HTTP request (e.g., network issues, invalid URL),
    		// return the error immediately.
    		err := fmt.Errorf("failed to create HTTP request to %s: %w", url, err)
    		return mcp.NewToolResultError(err.Error()), err
    	}

    	resp, err := http.DefaultClient.Do(httpRequest)
    	if err != nil {
    		// If there's an error during the HTTP request (e.g., network issues, invalid URL),
    		// return the error immediately.
    		err := fmt.Errorf("failed to send HTTP request to %s: %w", url, err)
    		return mcp.NewToolResultError(err.Error()), err
    	}
    	// Defer closing the response body. This ensures that the body is closed
    	// even if there are errors later in the function, preventing resource leaks.
    	defer resp.Body.Close()

    	// Check the HTTP status code. If it's not a 2xx success code,
    	// it's usually an indication of an error on the server side or a client error.
    	if resp.StatusCode != http.StatusOK { // http.StatusOK is 200
    		err := fmt.Errorf("received non-OK HTTP status for %s: %s", url, resp.Status)
    		return mcp.NewToolResultError(err.Error()), err
    	}

    	// Read the entire response body into a byte slice.
    	// io.ReadAll is convenient for reading all data from an io.Reader.
    	bodyBytes, err := io.ReadAll(resp.Body)
    	if err != nil {
    		// If there's an error reading the response body, return the error.
    		err := fmt.Errorf("failed to read response body from %s: %w", url, err)
    		return mcp.NewToolResultError(err.Error()), err
    	}

    	return mcp.NewToolResultText(string(bodyBytes)), nil
}
{{end}}